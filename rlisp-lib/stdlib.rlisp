; empty : list[a]
; (define empty '())

; compose : (b -> c) (a -> b) -> (a -> c)
(define (compose f g)
    (lambda [x] (f (g x))))

; ; println : ...a -> nil
; (define (println ...strs)
;     (begin
;         (apply display strs)
;         (newline)))

(define <> cons)

(define (apply f xs)
    (eval {'f <> xs}))

(define (println x)
    (display x)
    (newline))

; foldr : (a b -> b) b list[a] -> b
(define (foldl f acc xs)
    (cond [(empty? xs) acc]
          [else (foldl f (f (head xs) acc) (tail xs))]))

(define (foldr f acc xs)
    (cond [(empty? xs) acc]
          [else (f (head xs) (foldr f acc (tail xs)))]))

; map : (a -> b) list[a] -> list[b]
(define (map f xs)
    (cond [(empty? xs) empty]
          [else (cons (f (head xs)) (map f (tail xs)))]))

; sum : list[num] -> num
(define (sum xs)
    (apply + xs))

(define (product xs)
    (apply * xs))

(define (range from to)
    (cond [{from = to} empty]
          [else (cons from (range {from + 1} to))]))

(define {x to y}
    (range x {y + 1}))

; singleton : a -> list[a]
(define (singleton x)
    (cons x empty))

; append : a list[a] -> list[a]
(define (append x xs)
    (cond [(empty? xs) (singleton x)]
          [else (cons (head xs) (append x (tail xs)))]))

; (define foldr (lambda [f] (lambda [acc] (lambda [xs]
;     (cond [(empty? xs) xs]
;           [else (foldr f (f (head xs) acc) (tail xs))])))))

; Defines the prompt used by the REPL. If none is defined, it defaults to "> ".
(define PROMPT "rlisp> ")

; (define-syntax reload
;     (syntax-rules []
;         (reload)
;         (import "stdlib.rlisp")))

(define (prompt p)
    (display p)
    (readline))

(define print display)
(define (println s)
    (display s)
    (newline))

(define (factorial n)
    (product {1 to n}))

(define (repl)
    (print PROMPT)
    (println (eval (parse (readline))))
    (repl))